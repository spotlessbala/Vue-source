<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WVue</title>
</head>

<body>
  <div id="root">
		<p>{{name}}</p>
		<p>{{message}}</p>
  </div>
  
  <script>
    // 虚拟DOM 构造函数
    class VNode {
      constructor(tag, data, value, type) {
        this.tag = tag
        this.data = data
        this.value = value
        this.type = type
        this.children = []
      }

      appendChild(vnode) {
        this.children.push(vnode)
      }
    }

    // 根据传入的路径获取值    
    function getValueByPath(obj, paths) {
      let pathsArr = paths.split(".")

      let res = obj
      let prop

      while (prop = pathsArr.shift()) {
        res = res[prop]
      }

      return res
    }

    // 根据传入的 node 获取 虚拟DOM
    function getVNode(node) {
      let _vnode = null
      let nodeType = node.nodeType

      if (nodeType === 1) {
        let nodeTag = node.nodeName

        let nodeData = {}

        let nodeAttrs = node.attributes
        for (let i = 0; i < nodeAttrs.length; i++) {
          nodeData[nodeAttrs[i].nodeName] = nodeAttrs[i].nodeValue
        }

        _vnode = new VNode(nodeTag, nodeData, undefined, 1)

        for (let i = 0; i < node.childNodes.length; i++) {
          _vnode.appendChild(getVNode(node.childNodes[i]))
        }
      } else if (nodeType === 3) {
        _vnode = new VNode(undefined, undefined, node.nodeValue, 3)
      }

      return _vnode
    }
    
    // 解析模板 将 template 中的 {{}} 替换为 data 中的值
    let rKuohao = /\{\{(.*?)\}\}/g
    function compile(template, data) {
      let _tag = template.tag
      let _data = template.data
      let _value = template.value
      let _type = template.type
      let _children = template.children

      if (_type === 1) {
        for (let i = 0; i < _children.length; i++) {
          let childTem = _children[i];
          compile(childTem, data)
        }
      } else if (_type === 3) {
        _value = _value.replace(rKuohao, function (_, g) {
          return getValueByPath(data, g)
        })
        template.value = _value
      }
    }

    // 虚拟DOM转换为真实DOM
    function parseVNode (vnode) {
      let type = vnode.type
      let node = null
      // debugger
      if (type === 1) {
        // 创建元素
        node = document.createElement(vnode.tag)

        // 添加元素属性
        let data = vnode.data
        Object.keys(data).forEach(key => {
          attrName = key
          attrValue = data[key]

          node.setAttribute(key, data[key])
        })

        // 添加元素子元素
        vnode.children.forEach(subvnode => {
          node.appendChild(parseVNode(subvnode))
        })
      } else if (type === 3) {
        node = document.createTextNode(vnode.value)
      }

      return node
    }
    
    function WVue(option) {
      this._data = option.data
      this.$el = this._el = document.querySelector(option.el)
      this._patent = document.querySelector(option.el).parentNode

      this.mount()
    }

    WVue.prototype.mount = function () {
      this.render = this.creatRenderFn()
      this.mountCompontne()
    }

    WVue.prototype.mountCompontne = function () {
      let mount = () => {
        this.updata(this.render())
      }
      mount.call(this)
    }

    // 这里生成 render 函数 目的是缓存抽象语法树 此处我们模拟为 缓存 虚拟 DOM。
    WVue.prototype.creatRenderFn = function () {
      let _ast = getVNode(this._el)
      return function () {
        compile(_ast, this._data)
        let node = parseVNode(_ast)
        return node
      }
    }

    // 此处将 虚拟DOM 渲染到页面中 使用大家常说的 diff 算法
    WVue.prototype.updata = function (node) {
      
      this._patent.replaceChild(node, document.querySelector("#root"))
    }

		let app = new WVue({
			el: "#root",
			data: {
				name: "赛利亚",
				message: "你好啊"
			}
		})

  </script>
</body>

</html>